{"version":3,"sources":["webpack://jso/webpack/universalModuleDefinition","webpack://jso/webpack/bootstrap","webpack://jso/webpack/runtime/define property getters","webpack://jso/webpack/runtime/hasOwnProperty shorthand","webpack://jso/webpack/runtime/make namespace object","webpack://jso/./src/utils.js","webpack://jso/./src/store-session.js","webpack://jso/./src/Loaders/BasicLoader.js","webpack://jso/./src/Loaders/HTTPRedirect.js","webpack://jso/./src/Loaders/IFramePassive.js","webpack://jso/./src/Loaders/IFrameActive.js","webpack://jso/./src/Loaders/Popup.js","webpack://jso/./src/errors/Error.js","webpack://jso/./src/errors/ExpiredTokenError.js","webpack://jso/./src/HTTP/Fetcher.js","webpack://jso/./src/HTTP/FetcherJQuery.js","webpack://jso/./src/errors/OAuthResponseError.js","webpack://jso/./src/Config.js","webpack://jso/./src/EventEmitter.js","webpack://jso/./src/JSO.js"],"names":["root","factory","exports","module","define","amd","self","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","utils","Math","round","Date","getTime","replace","c","random","toString","url","indexOf","parseQueryString","substring","qs","e","a","s","decodeURIComponent","q","urlParams","exec","scopes","uniqueList","join","items","uniqueItems","resultItems","i","length","push","msg","console","log","debug","args","Array","slice","arguments","unshift","apply","params","k","res","encodeURIComponent","firstSeparator","str","window","crypto","subtle","digest","TextEncoder","encode","buff","btoa","Uint8Array","reduce","b","String","fromCharCode","buf","encode64","code_verifier","sha256Hash","then","hashed","base64UrlSafeEncode","catch","error","finally","state","sessionStorage","setItem","JSON","stringify","parse","getItem","removeItem","token","scope","tokens","j","usethis","result","now","expires","this","hasScope","provider","location","href","getTokens","filterTokens","saveTokens","BasicLoader","HTTPRedirect","Promise","resolve","reject","IFramePassive","timeout","callback","isCompleted","id","eventMethod","addEventListener","iframe","document","createElement","setAttribute","object","contentWindow","hash","encodedHash","search","_completed","_failed","Error","err","errorCallback","getElementsByTagName","appendChild","setTimeout","element","getElementById","parentNode","removeChild","_cleanup","response","IFrameActive","theIframe","postMessage","origin","event","data","focus","Popup","popupCompleted","newwindow","left","screen","width","w","top","height","h","open","props","ExpiredTokenError","Fetcher","jso","opts","fetch","status","reccur","getTokenOpts","fetchOpts","assign","getToken","headers","Authorization","access_token","_fetch","wipeTokens","FetcherJQuery","jquery","done","fail","jqXHR","textStatus","errorThrown","parseInt","ajax","OAuthResponseError","error_description","Config","config","use_pkce","pointer","splittedKeys","split","defaultValue","isRequired","EventEmitter","type","_callbacks","require","default_config","lifetime","response_type","JSO","configure","connector_name","getconnector_name","Loader","store","callbacks","getValue","newstore","loader","client_id","atoken","getState","processReceivedToken","received","expires_in","has","saveToken","signal","CustomEvent","bubbles","detail","dispatchEvent","Headers","append","tokenRequest","code","redirect_uri","mode","method","body","httpResponse","json","tokenResponse","restoreHash","processTokenResponse","processAuthorizationCodeResponse","processErrorResponse","request","authorization","authurl","saveState","gotoAuthorizeURL","openid","includes","nonce","cv","_authorize2","getRandomValues","cc","code_challenge","code_challenge_method","execute"],"mappings":"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","file":"jso.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jso\"] = factory();\n\telse\n\t\troot[\"jso\"] = factory();\n})(self, function() {\nreturn ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","let utils = {}\n\n/*\n * Returns epoch, seconds since 1970.\n * Used for calculation of expire times.\n */\nutils.epoch = function () {\n\treturn Math.round(new Date().getTime() / 1000.0)\n}\n\nutils.debug = false\n\n/*\n * Returns a random string used for state\n */\nutils.uuid = function () {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\tvar r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8)\n\t\treturn v.toString(16)\n\t})\n}\n\n/*\n * Takes a full url as input and expect it to have an encoded response\n * object as eigther a query string or an encoded fragment.\n * Returns the decoded object, or throws an error if no query string or fragment.\n */\nutils.getResponseFromURL = function (url) {\n\tif (url.indexOf('#') !== -1) {\n\t\treturn utils.parseQueryString(url.substring(url.indexOf('#') + 1))\n\t} else if (url.indexOf('?') !== -1) {\n\t\treturn utils.parseQueryString(url.substring(url.indexOf('?') + 1))\n\t}\n\treturn {}\n}\n\nutils.parseQueryString = function (qs) {\n\tvar e,\n\t\ta = /\\+/g,  // Regex for replacing addition symbol with a space\n\t\tr = /([^&;=]+)=?([^&;]*)/g,\n\t\td = function (s) { return decodeURIComponent(s.replace(a, \" \")) },\n\t\tq = qs,\n\t\turlParams = {}\n\n\t/* jshint ignore:start */\n\twhile (e = r.exec(q)) {\n\t\turlParams[d(e[1])] = d(e[2])\n\t};\n\t/* jshint ignore:end */\n\n\treturn urlParams\n}\n\n\n\n\n\n/**\n * Utility: scopeList(scopes )\n * Takes a list of scopes that might be overlapping, and removed duplicates,\n * then concatenates the list by spaces and returns a string.\n *\n * @param  {[type]} scopes [description]\n * @return {[type]}        [description]\n */\nutils.scopeList = function (scopes) {\n\treturn utils.uniqueList(scopes).join(' ')\n}\n\n\nutils.uniqueList = function (items) {\n\tvar uniqueItems = {}\n\tvar resultItems = []\n\tfor (var i = 0; i < items.length; i++) {\n\t\tuniqueItems[items[i]] = 1\n\t}\n\tfor (var key in uniqueItems) {\n\t\tif (uniqueItems.hasOwnProperty(key)) {\n\t\t\tresultItems.push(key)\n\t\t}\n\t}\n\treturn resultItems\n}\n\n\n\n/**\n * A log wrapper, that only logs if logging is turned on in the config\n * @param  {string} msg Log message\n */\nutils.log = function (msg) {\n\tif (!console) return\n\tif (!console.log) return\n\tif (!utils.debug) return\n\n\tlet args = Array.prototype.slice.call(arguments)\n\targs.unshift('[JSO]')\n\tconsole.log.apply(console, args)\n\n}\n\nutils.encodeQS = function (params) {\n\tlet res = ''\n\tvar k, i = 0\n\tfor (k in params) {\n\t\tres += (i++ === 0 ? '' : '&') + encodeURIComponent(k) + '=' + encodeURIComponent(params[k])\n\t}\n\treturn res\n}\n\n/*\n * Takes an URL as input and a params object.\n * Each property in the params is added to the url as query string parameters\n */\nutils.encodeURL = function (url, params) {\n\tvar res = url\n\tvar k, i = 0\n\tvar firstSeparator = (url.indexOf(\"?\") === -1) ? '?' : '&'\n\tfor (k in params) {\n\t\tres += (i++ === 0 ? firstSeparator : '&') + encodeURIComponent(k) + '=' + encodeURIComponent(params[k])\n\t}\n\treturn res\n}\n\n\nutils.sha256Hash = function (str) {\n\treturn window.crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(str));\n}\n\n// Base64 encode\nutils.encode64 = function (buff) {\n\treturn btoa(new Uint8Array(buff).reduce((s, b) => s + String.fromCharCode(b), ''));\n}\n\n/* \n * Base64 url safe encoding of an array\n */\nutils.base64UrlSafeEncode = function (buf) {\n\tconst s = utils.encode64(buf).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\")\n\treturn s\n}\n\n\n/* Calc code verifier if necessary\n */\nutils.getCodeChallenge = function (code_verifier) {\n\treturn utils.sha256Hash(code_verifier).then(\n\t\t(hashed) => {\n\t\t\treturn utils.base64UrlSafeEncode(hashed)\n\t\t}\n\t).catch(\n\t\t(error) => { utils.log(error) }\n\t).finally(\n\t\t() => { return null }\n\t)\n}\n\nexport default utils\n","import utils from './utils'\n\nclass Store {\n\n\tconstructor() {\n\t\t\n\t}\n\n\t/*\n\t\tsaveState stores an object with an Identifier.\n\t\tTODO: Ensure that both sessionStorage and JSON encoding has fallbacks for ancient browsers.\n\t\tIn the state object, we put the request object, plus these parameters:\n\t\t  * restoreHash\n\t\t  * connector_name\n\t\t  * scopes\n\n\t */\n\tsaveState(state, obj) {\t\t\n\t\tsessionStorage.setItem(\"state-\" + state, JSON.stringify(obj))\n\t}\n\n\t/**\n\t * getStage()  returns the state object, but also removes it.\n\t * @type {Object}\n\t */\n\tgetState(state) {\n\t\t// log(\"getState (\" + state+ \")\");\n\t\tvar obj = JSON.parse(sessionStorage.getItem(\"state-\" + state))\n\t\tsessionStorage.removeItem(\"state-\" + state)\n\t\treturn obj\n\t}\n\n\n\t/*\n\t * Checks if a token, has includes a specific scope.\n\t * If token has no scope at all, false is returned.\n\t */\n\thasScope(token, scope) {\n\t\tvar i\n\t\tif (!token.scopes) return false\n\t\tfor(i = 0; i < token.scopes.length; i++) {\n\t\t\tif (token.scopes[i] === scope) return true\n\t\t}\n\t\treturn false\n\t}\n\n\t/*\n\t * Takes an array of tokens, and removes the ones that\n\t * are expired, and the ones that do not meet a scopes requirement.\n\t */\n\tfilterTokens(tokens, scopes) {\n\t\tvar i, j,\n\t\t\tresult = [],\n\t\t\tnow = utils.epoch(),\n\t\t\tusethis\n\n\t\tif (!scopes) scopes = []\n\n\t\tfor(i = 0; i < tokens.length; i++) {\n\t\t\tusethis = true\n\n\t\t\t// Filter out expired tokens. Tokens that is expired in 1 second from now.\n\t\t\tif (tokens[i].expires && tokens[i].expires < (now+1)) usethis = false\n\n\t\t\t// Filter out this token if not all scope requirements are met\n\t\t\tfor(j = 0; j < scopes.length; j++) {\n\t\t\t\tif (!this.hasScope(tokens[i], scopes[j])) usethis = false\n\t\t\t}\n\n\t\t\tif (usethis) result.push(tokens[i])\n\t\t}\n\t\treturn result\n\t}\n\n\n\t/*\n\t * saveTokens() stores a list of tokens for a provider.\n\n\t\tUsually the tokens stored are a plain Access token plus:\n\t\t  * expires : time that the token expires\n\t\t  * connector_name: the provider of the access token?\n\t\t  * scopes: an array with the scopes (not string)\n\t */\n\tsaveTokens(provider, tokens) {\n\t\t// log(\"Save Tokens (\" + provider+ \")\");\n\t\tsessionStorage.setItem(\"tokens-\" + provider, JSON.stringify(tokens))\n\t}\n\n\tgetTokens(provider) {\n\t\t// log(\"Get Tokens (\" + provider+ \")\");\n\t\tvar tokens = JSON.parse(sessionStorage.getItem(\"tokens-\" + provider));\n\t\tif (!tokens) tokens = [];\n\n\t\tutils.log(\"Token found when loooking up provider \" + provider + \" in store \" + window.location.href, tokens);\n\t\treturn tokens;\n\t}\n\n\twipeTokens(provider) {\n\t\tsessionStorage.removeItem(\"tokens-\" + provider)\n\t}\n\n\t/*\n\t * Save a single token for a provider.\n\t * This also cleans up expired tokens for the same provider.\n\t */\n\tsaveToken(provider, token) {\n\t\tvar tokens = this.getTokens(provider)\n\t\ttokens = this.filterTokens(tokens)\n\t\ttokens.push(token)\n\t\tthis.saveTokens(provider, tokens)\n\t}\n\n\t/*\n\t * Get a token if exists for a provider with a set of scopes.\n\t * The scopes parameter is OPTIONAL.\n\t */\n\tgetToken(provider, scopes) {\n\t\tvar tokens = this.getTokens(provider)\n\t\ttokens = this.filterTokens(tokens, scopes)\n\t\tif (tokens.length < 1) return null\n\t\treturn tokens[0]\n\t};\n\n}\n\nvar s = new Store()\n\nexport default s\n","export default class BasicLoader {\n\tconstructor(url) {\n\t\tconsole.log(\"Initializing a loader with url \" + url)\n\t\tthis.url = url\n\t}\n\texecute() {\n\n\t}\n}\n","import BasicLoader from './BasicLoader'\nimport utils from '../utils'\n\nexport default class HTTPRedirect extends BasicLoader {\n\texecute() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\twindow.location = this.url\n\t\t})\n\t}\n}\n","import BasicLoader from './BasicLoader'\nimport utils from '../utils'\n\nexport default class IFramePassive extends BasicLoader {\n\n\tconstructor(url) {\n\t\tsuper(url)\n\n\t\tthis.timeout = 5000\n\t\tthis.callback = null\n\t\tthis.isCompleted = false\n    this.id = 'jso_passive_iframe_' + utils.uuid()\n\n    // Create IE + others compatible event handler\n    var eventMethod = window.addEventListener ? \"addEventListener\" : \"attachEvent\"\n    var eventer = window[eventMethod]\n    var messageEvent = eventMethod == \"attachEvent\" ? \"onmessage\" : \"message\"\n\n    this.iframe = document.createElement('iframe')\n    this.iframe.setAttribute('id', this.id)\n    this.iframe.setAttribute('src', url)\n\n    this.iframe.addEventListener('load', (e) => {\n\n      let object = null\n      try {\n        if (this.iframe.contentWindow.location.hash) {\n          let encodedHash = this.iframe.contentWindow.location.hash.substring(1)\n          object = utils.parseQueryString(encodedHash)\n        } else if (this.iframe.contentWindow.location.search) {\n          let encodedHash = this.iframe.contentWindow.location.search.substring(1)\n          object = utils.parseQueryString(encodedHash)\n        }\n\n        if (object !== null) {\n          this._completed(object)\n        } else {\n          this._failed(new Error(\"Failed to obtain response value from iframe\"))\n        }\n      } catch(err) {\n        // Most likely not able to access the content window because of same-origin policy.\n        //\n        // Ignore this error, as this is likely to happen during the SSO redirect loop, but the load\n        // event may be triggered multiple times, so it is not neccessary a problem that the first is not\n        // accessible.\n      }\n\n    })\n\n\t}\n\n\texecute() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.callback = resolve\n      this.errorCallback = reject\n      document.getElementsByTagName('body')[0].appendChild(this.iframe)\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._failed(new Error(\"Loading iframe timed out\"))\n\t\t\t}, this.timeout)\n\t\t})\n\t}\n\n\n\t_cleanup() {\n    let element = document.getElementById(this.id)\n    element.parentNode.removeChild(element)\n\t}\n\n  _failed(err) {\n    if (!this.isCompleted) {\n\t\t\tif (this.errorCallback && typeof this.errorCallback === 'function') {\n\t\t\t\tthis.errorCallback(err)\n\t\t\t}\n\t\t\tthis.isCompleted = true\n\t\t\tthis._cleanup()\n\t\t}\n  }\n\n\t_completed(response) {\n\t\tif (!this.isCompleted) {\n\t\t\tif (this.callback && typeof this.callback === 'function') {\n\t\t\t\tthis.callback(response)\n\t\t\t}\n\t\t\tthis.isCompleted = true\n\t\t\tthis._cleanup()\n\t\t}\n\t}\n}\n","import BasicLoader from './BasicLoader'\nimport utils from '../utils'\n\nexport default class IFrameActive extends BasicLoader {\n\n  execute() {\n\n\t  return new Promise((resolve, reject) => {\n\n      /*\n      // Create IE + others compatible event handler\n      var eventMethod = window.addEventListener ? \"addEventListener\" : \"attachEvent\"\n      var eventer = window[eventMethod]\n      var messageEvent = eventMethod == \"attachEvent\" ? \"onmessage\" : \"message\"\n      */\n\n      // Using a specific expected name for now.  Would be better if the loader constructor also passed in\n      //  \"opts\" structure, so each loader might add specific initialization properties necessary fo the\n      //  particular loader\n      let theIframe = document.getElementById(\"jsoActiveIframe\");\n\n      function doIframeLoad() {\n        let oWin = theIframe.contentWindow;\n\n          // When page is loaded try to post a message to it to get back the message\n          try {\n            theIframe.contentWindow.postMessage(\"JSO\", window.location.origin);\n          } catch (e) {\n            // do nothing if this window is from a different domain and it fails\n          }\n          // In case we need to send a post message to the loaded iframe window before it\n          // can send us a message\n      }\n\n      theIframe.addEventListener(\"load\", doIframeLoad, true);\n\n\n      let messageReceiver = (event) => {\n        // Check origin\n        if( event.origin != location.origin)\n          return;\n        var url = event.data.toString();\n        if( -1 != url.indexOf(\"?code=\") ) {\n          resolve(url);\n        }\n      };\n\n      // Setup call back function to receive postMessage from page loaded in iframe\n      window.addEventListener(\"message\", messageReceiver, false);\n \n      theIframe.setAttribute(\"src\", this.url);\n\n\n\t\t\tif (window.focus) {\n        if( theIframe.contentWindow ) {\n          theIframe.contentWindow.focus()\n        }\n\t\t\t}\n\n\t\t})\n\t}\n}\n","import BasicLoader from './BasicLoader'\n\nexport default class Popup extends BasicLoader {\n\n\texecute() {\n\n\t\t/*\n\t\t* In the popup's scripts, running on <http://example.org>:\n\t\t*/\n\t\treturn new Promise((resolve, reject) => {\n\n\t\t\t// window.addEventListener(\"jso_message\", function(event) {\n\t\t\t// \tconsole.log(\"Sent a message to event.origin \" + event.origin + \" and got the following in response:\")\n\t\t\t// \tconsole.log(\"<em>\", event.data, \"</em>\")\n\t\t\t// \tvar url = newwindow.location.href\n\t\t\t// \t// console.error(\"Popup location is \", url, newwindow.location)\n\t\t\t//   resolve(url)\n\t\t\t// })\n\n\t\t\twindow.popupCompleted = function () {\n\t\t\t\tvar url = newwindow.location.href;\n\t\t\t\tresolve(url)\n\t\t\t}\n\n\t\t\tvar w = 420;\n\t\t\tvar h = 650;\n\t\t\tvar left = (screen.width/2)-(w/2);\n\t\t\tvar top = (screen.height/2)-(h/2);\n\n\t\t\tvar newwindow = window.open(this.url, 'jso-popup-auth', 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width='+w+', height='+h+', top='+top+', left='+left);\n\t\t\tif (newwindow === null) {\n\t\t\t\tthrow new Error(\"Error loading popup window\");\n\t\t\t}\n\n\t\t\tif (window.focus) {\n\t\t\t\tnewwindow.focus();\n\t\t\t}\n\n\t\t})\n\t}\n}\n","\nexport default class Error {\n\tconstructor(props) {\n\t\tfor(var key in props) {\n\t\t\tthis[key] = props[key];\n\t\t}\n\t}\n\n\tset(key, value) {\n\t\tthis[key] = value;\n\t\treturn this;\n\t}\n}","import Error from './Error';\n\nexport default class ExpiredTokenError extends Error {\n\n}","\nimport ExpiredTokenError from '../errors/ExpiredTokenError'\n\nexport default class Fetcher {\n\tconstructor(jso) {\n    this.jso = jso\n\t}\n\n  _fetch(url, opts) {\n    return fetch(url, opts)\n      .then((response) => {\n        if (response.status === 401) {\n          throw new ExpiredTokenError()\n        }\n        return response\n      })\n  }\n\n\tfetch(url, opts, reccur) {\n    reccur = reccur ? reccur : 0\n    if (reccur > 2) {\n      throw new Error(\"Reccursion error. Expired tokens deleted and tried again multiple times.\")\n    }\n    let getTokenOpts = {}\n    let fetchOpts = {\n      'mode': 'cors'\n    }\n    if (opts) {\n      fetchOpts = opts\n      Object.assign(fetchOpts, opts)\n    }\n    if (opts && opts.jso) {\n      Object.assign(getTokenOpts, opts.jso)\n    }\n\n    return this.jso.getToken(getTokenOpts)\n      .catch((err) => {\n        console.error(\"Error fetching token to use \", err)\n      })\n      .then((token) => {\n      \t// console.log(\"I got the token: \", token.access_token)\n\n        if (!fetchOpts.headers) {\n          fetchOpts.headers = {}\n        }\n        fetchOpts.headers.Authorization = 'Bearer ' + token.access_token\n        return this._fetch(url, fetchOpts)\n          .catch((err) => {\n            if (err instanceof ExpiredTokenError) {\n              console.error(\"Token was expired. Deleting all tokens for this provider and get a new one\", err)\n              this.jso.wipeTokens()\n              return this.fetch(url, opts, reccur+1)\n            }\n          })\n\n      })\n\t}\n\n\n\n}\n","import ExpiredTokenError from '../errors/ExpiredTokenError'\n\nexport default class FetcherJQuery {\n\tconstructor(jso, jquery) {\n    this.jso = jso\n    this.jquery = jquery\n\t}\n\n  _fetch(url, opts) {\n\n    return new Promise((resolve, reject) => {\n\n      opts.done = resolve\n      opts.fail = (jqXHR, textStatus, errorThrown) => {\n        let status = parseInt(textStatus, 10)\n        if (status === 401) {\n          this.jso.wipeTokens()\n          return reject(new ExpiredTokenError())\n        }\n        return reject(errorThrown)\n      }\n      return this.jquery.ajax(url, opts)\n\n    })\n\n  }\n\n\tfetch(url, opts, reccur) {\n    reccur = reccur ? reccur : 0\n    if (reccur > 2) {\n      throw new Error(\"Reccursion error. Expired tokens deleted and tried again multiple times.\")\n    }\n    let getTokenOpts = {}\n    let fetchOpts = {\n      'mode': 'cors'\n    }\n    if (opts) {\n      fetchOpts = opts\n      Object.assign(fetchOpts, opts)\n    }\n    if (opts && opts.jso) {\n      Object.assign(getTokenOpts, opts.jso)\n    }\n\n    return this.jso.getToken(getTokenOpts)\n      .catch((err) => {\n        console.error(\"Error fetching token to use \", err)\n      })\n      .then((token) => {\n      \t// console.log(\"I got the token: \", token.access_token)\n\n        if (!fetchOpts.headers) {\n          fetchOpts.headers = {}\n        }\n        fetchOpts.headers.Authorization = 'Bearer ' + token.access_token\n        return this._fetch(url, fetchOpts)\n          .catch((err) => {\n            if (err instanceof ExpiredTokenError) {\n              console.error(\"Token was expired. Deleting all tokens for this provider and get a new one\", err)\n              this.jso.wipeTokens()\n              return this.fetch(url, opts, reccur+1)\n            }\n          })\n\n      })\n\t}\n\n\n\n}\n","import Error from './Error'\n\nexport default class OAuthResponseError extends Error {\n\n  toString() {\n    let header = this.error || 'unknown'\n    let descr = this.error_description || 'unknown'\n    return 'OAuthResponseError: [' + header + ']: ' + descr\n  }\n}\n","export default class Config {\n\n\tconstructor() {\n\t\tthis.config = {}\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tObject.assign(this.config, arguments[i]);\n\t\t}\n\n\t\t// enable pkce when token endpoint is provided\n\t\tif(this.config.token) this.config.use_pkce = true;\n\t}\n\n\thas(key) {\n\t\tvar pointer = this.config\n\t\tvar splittedKeys = key.split('.')\n\t\tvar i = 0\n\t\tfor (i = 0; i < splittedKeys.length; i++) {\n\t\t\tif (pointer.hasOwnProperty(splittedKeys[i])) {\n\t\t\t\tpointer = pointer[splittedKeys[i]]\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tgetValue(key, defaultValue, isRequired) {\n\t\tvar isRequired = isRequired || false\n\t\tvar pointer = this.config\n\t\tvar splittedKeys = key.split('.')\n\t\tvar i = 0\n\t\tfor (i = 0; i < splittedKeys.length; i++) {\n\n\t\t\tif (pointer.hasOwnProperty(splittedKeys[i])) {\n\t\t\t\t// console.log(\"POINTING TO \" + splittedKeys[i]);\n\t\t\t\tpointer = pointer[splittedKeys[i]]\n\t\t\t} else {\n\t\t\t\tpointer = undefined\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (typeof pointer === 'undefined') {\n\t\t\tif (isRequired) {\n\t\t\t\tthrow new Error(\"Configuration option [\" + splittedKeys[i] + \"] required but not provided.\")\n\t\t\t}\n\t\t\treturn defaultValue\n\t\t}\n\t\treturn pointer\n\t}\n}\n","export default class EventEmitter {\n\n  on(type, callback) {\n    if (!this._callbacks) {\n      this._callbacks = {}\n    }\n    if (!this._callbacks[type]) {\n      this._callbacks[type] = []\n    }\n\n    this._callbacks[type].push(callback)\n  }\n\n  emit(type) {\n    if (!this._callbacks) {\n      this._callbacks = {}\n    }\n    if (!this._callbacks[type]) {\n      this._callbacks[type] = []\n    }\n\n    var args = Array.prototype.slice.call(arguments, 1)\n    for(var i = 0; i < this._callbacks[type].length; i++) {\n      this._callbacks[type][i].apply(this, args)\n    }\n  }\n}\n","/**\n * JSO - Javascript OAuth Library\n * \tVersion 4.0\n *  UNINETT AS - http://uninett.no\n *  Author: Andreas Åkre Solberg <andreas.solberg@uninett.no>\n *  Licence: Simplified BSD Licence\n *\n *  Documentation available at: https://github.com/andreassolberg/jso\n */\n\n\nimport store from './store-session'\nimport utils from './utils'\n\n// Work in progress\n// import Authentication from './Authentication/Authentication'\n\nimport BasicLoader from './Loaders/BasicLoader'\nimport HTTPRedirect from './Loaders/HTTPRedirect'\nimport IFramePassive from './Loaders/IFramePassive'\nimport IFrameActive from './Loaders/IFrameActive'\nimport Popup from './Loaders/Popup'\n\nimport Fetcher from './HTTP/Fetcher'\nimport FetcherJQuery from './HTTP/FetcherJQuery'\n\n// import ExpiredTokenError from './errors/ExpiredTokenError'\n// import HTTPError from './errors/HTTPError'\nimport OAuthResponseError from './errors/OAuthResponseError'\n\nimport Config from './Config'\nimport EventEmitter from './EventEmitter'\n\nconst package_json = require('../package.json')\n\nconst default_config = {\n\tlifetime: 3600,\n\tresponse_type: 'token',\n}\n\nclass JSO extends EventEmitter {\n\n\tconstructor(config) {\n\t\tsuper();\n\t\tthis.configure(config);\n\t\tthis.connector_name = this.getconnector_name();\n\t\tthis.Loader = Popup; // HTTPRedirect;\n\t\tthis.store = store;\n\t\tthis.callbacks = {};\n\n\t\tif (this.config.getValue('debug', false)) {\n\t\t\tutils.debug = true;\n\t\t}\n\t}\n\n\tconfigure(config) {\n\t\tthis.config = new Config(default_config, config);\n\t}\n\n\t// Experimental, nothing but default store exists yet. Not documented.\n\tsetStore(newstore) {\n\t\tthis.store = newstore\n\t}\n\n\tsetLoader(loader) {\n\t\tif (typeof loader === \"function\") {\n\t\t\tthis.Loader = loader\n\t\t} else {\n\t\t\tthrow new Error(\"loader MUST be an instance of the JSO BasicLoader\")\n\t\t}\n\t}\n\n\n\n\t/**\n\t * We need to get an identifier to represent this OAuth provider.\n\t * The JSO construction option connector_name is preferred, if not provided\n\t * we construct a concatentaion of authorization url and client_id.\n\t * @return {[type]} [description]\n\t */\n\tgetconnector_name() {\n\n\t\tvar c = this.config.getValue('connector_name', null)\n\t\tif (c !== null) { return c }\n\n\t\tvar client_id = this.config.getValue('client_id', null, true)\n\t\tvar authorization = this.config.getValue('authorization', null, true)\n\n\t\treturn authorization + '|' + client_id\n\t}\n\n\t/**\n\t * If the callback has already successfully parsed a token response, call this.\n\t * @return {[type]} [description]\n\t */\n\tprocessTokenResponse(atoken) {\n\t\tlet state\n\t\tif (atoken.state) {\n\t\t\tstate = this.store.getState(atoken.state)\n\t\t} else {\n\t\t\tthrow new Error(\"Could not get state from storage.\")\n\t\t}\n\n\t\tif (!state) {\n\t\t\tthrow new Error(\"Could not retrieve state\")\n\t\t}\n\t\tif (!state.connector_name) {\n\t\t\tthrow new Error(\"Could not get connector_name from state\")\n\t\t}\n\t\tutils.log(\"processTokenResponse \", atoken, \"\")\n\t\treturn this.processReceivedToken(atoken, state)\n\t}\n\n\tprocessReceivedToken(atoken, state) {\n\t\t/*\n\t\t\t * Decide when this token should expire.\n\t\t\t * Priority fallback:\n\t\t\t * 1. Access token expires_in\n\t\t\t * 2. Life time in config (may be false = permanent...)\n\t\t\t * 3. Specific permanent scope.\n\t\t\t * 4. Default library lifetime:\n\t\t\t */\n\t\tlet now = utils.epoch()\n\t\tatoken.received = now\n\t\tif (atoken.expires_in) {\n\t\t\tatoken.expires = now + parseInt(atoken.expires_in, 10)\n\t\t\tatoken.expires_in = parseInt(atoken.expires_in, 10)\n\t\t} else if (this.config.getValue('default_lifetime', null) === false) {\n\t\t\tatoken.expires = null\n\t\t} else if (this.config.has('permanent_scope')) {\n\t\t\tif (!this.store.hasScope(atoken, this.config.getValue('permanent_scope'))) {\n\t\t\t\tatoken.expires = null\n\t\t\t}\n\t\t} else if (this.config.has('default_lifetime')) {\n\t\t\tatoken.expires = now + this.config.getValue('default_lifetime')\n\t\t} else {\n\t\t\tatoken.expires = now + 3600\n\t\t}\n\n\t\t/*\n\t\t * Handle scopes for this token\n\t\t */\n\t\tif (atoken.scope) {\n\t\t\tatoken.scopes = atoken.scope.split(\" \");\n\t\t\tdelete atoken.scope;\n\t\t} else if (state.scopes) {\n\t\t\tatoken.scopes = state.scopes;\n\t\t} else {\n\t\t\tatoken.scopes = []\n\t\t}\n\n\t\tutils.log(\"processTokenResponse completed \", atoken, \"\");\n\n\t\tthis.store.saveToken(state.connector_name, atoken);\n\n\t\t// create non bubbling named-signal event\n\t\tvar signal = new CustomEvent(\"signal-token-received\", {\n\t\t\tbubbles: false,\n\t\t\tdetail: atoken\n\t\t});\n\n\t\tdocument.dispatchEvent(signal);\n\n\t\treturn atoken;\n\t}\n\n\n\tprocessAuthorizationCodeResponse(object) {\n\n\t\t// this.emit('authorizationCode', object)\n\n\t\tlet state;\n\t\tif (object.state) {\n\t\t\tstate = this.store.getState(object.state)\n\t\t\tif (state === null) {\n\t\t\t\tthrow new Error(\"Could not find retrieve state object.\")\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Could not find state paramter from callback.\")\n\t\t}\n\n\t\tconsole.log(\"state\", state);\n\n\t\tif (!this.config.has('token')) {\n\t\t\tutils.log(\"Received an authorization code. Will not process it as the config option [token] endpoint is not set. If you would like to process the code yourself, please subscribe to the [authorizationCode] event\")\n\t\t\treturn\n\t\t}\n\n\t\tlet headers = new Headers();\n\t\theaders.append('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\n\t\tlet tokenRequest = {\n\t\t\t'grant_type': 'authorization_code',\n\t\t\t'client_id': this.config.getValue('client_id'),\n\t\t\t'code': object.code\n\t\t}\n\n\t\tif (this.config.getValue('use_pkce', false)) {\n\t\t\t// Also include the original created code_verifier\n\t\t\ttokenRequest.code_verifier = state.code_verifier\n\t\t}\n\n\t\tif (state.hasOwnProperty('redirect_uri')) {\n\t\t\ttokenRequest.redirect_uri = state.redirect_uri\n\t\t}\n\n\t\tlet opts = {\n\t\t\tmode: 'cors',\n\t\t\theaders: headers,\n\t\t\tmethod: 'POST', // or 'PUT'\n\t\t\tbody: utils.encodeQS(tokenRequest), // data can be `string` or {object}!\n\t\t}\n\n\t\treturn fetch(this.config.getValue('token'), opts)\n\t\t\t.then((httpResponse) => {\n\t\t\t\treturn httpResponse.json();\n\t\t\t})\n\t\t\t.then((tokenResponse) => {\n\t\t\t\tutils.log(\"Received response on token endpoint \", tokenResponse, \"\");\n\t\t\t\treturn this.processReceivedToken(tokenResponse, state);\n\t\t\t})\n\n\t\t// throw new Exception(\"Implementation of authorization code flow is not yet implemented. Instead use the implicit grant flow\")\n\n\t}\n\n\n\n\tprocessErrorResponse(err) {\n\n\t\tvar state\n\t\tif (err.state) {\n\n\t\t\tstate = this.store.getState(err.state)\n\t\t} else {\n\t\t\tthrow new Error(\"Could not get [state] and no default connector_name is provided.\")\n\t\t}\n\n\t\tif (!state) {\n\t\t\tthrow new Error(\"Could not retrieve state\")\n\t\t}\n\t\tif (!state.connector_name) {\n\t\t\tthrow new Error(\"Could not get connector_name from state\")\n\t\t}\n\n\t\tif (state.restoreHash) {\n\t\t\twindow.location.hash = state.restoreHash\n\t\t} else {\n\t\t\twindow.location.hash = ''\n\t\t}\n\t\treturn new OAuthResponseError(err)\n\n\t}\n\n\n\t/**\n\t * Check if the hash contains an access token.\n\t * And if it do, extract the state, compare with\n\t * config, and store the access token for later use.\n\t *\n\t * The url parameter is optional. Used with phonegap and\n\t * childbrowser when the jso context is not receiving the response,\n\t * instead the response is received on a child browser.\n\t */\n\tcallback(data) {\n\n\t\tdebugger;\n\n\t\tlet response = null\n\t\tif (typeof data === 'object') {\n\t\t\tresponse = data\n\t\t} else if (typeof data === 'string') {\n\t\t\tresponse = utils.getResponseFromURL(data)\n\t\t} else if (typeof data === 'undefined') {\n\t\t\tresponse = utils.getResponseFromURL(window.location.href)\n\t\t} else {\n\t\t\t// no response provided.\n\t\t\treturn\n\t\t}\n\n\t\tutils.log('Receving response in callback', response)\n\n\t\tif (response.hasOwnProperty(\"access_token\")) {\n\n\t\t\treturn this.processTokenResponse(response);\n\n\t\t} else if (response.hasOwnProperty(\"code\")) {\n\n\t\t\treturn this.processAuthorizationCodeResponse(response);\n\n\t\t} else if (response.hasOwnProperty(\"error\")) {\n\n\t\t\tthrow this.processErrorResponse(response);\n\n\t\t}\n\t}\n\n\n\tdump() {\n\t\tvar tokens = this.store.getTokens(this.connector_name)\n\t\tvar x = {\n\t\t\t\"connector_name\": this.connector_name,\n\t\t\t\"tokens\": tokens,\n\t\t\t\"config\": this.config\n\t\t}\n\t\treturn x\n\t}\n\n\t_getRequestScopes(opts) {\n\t\tvar scopes = [], i\n\t\t/*\n\t\t * Calculate which scopes to request, based upon provider config and request config.\n\t\t */\n\t\tif (this.config.has('scopes.request')) {\n\t\t\tlet s = this.config.getValue('scopes.request')\n\t\t\tfor (i = 0; i < s.length; i++) {\n\t\t\t\tscopes.push(s[i])\n\t\t\t}\n\t\t}\n\t\tif (opts && opts.scopes && opts.scopes.request) {\n\t\t\tfor (i = 0; i < opts.scopes.request.length; i++) { scopes.push(opts.scopes.request[i]) }\n\t\t}\n\t\treturn utils.uniqueList(scopes)\n\t}\n\n\t_getRequiredScopes(opts) {\n\t\tvar scopes = [], i\n\t\t/*\n\t\t * Calculate which scopes to request, based upon provider config and request config.\n\t\t */\n\t\tif (this.config.has('scopes.require')) {\n\t\t\tlet s = this.config.getValue('scopes.require')\n\t\t\tfor (i = 0; i < s.length; i++) {\n\t\t\t\tscopes.push(s[i])\n\t\t\t}\n\t\t}\n\t\tif (opts && opts.scopes && opts.scopes.require) {\n\t\t\tfor (i = 0; i < opts.scopes.require.length; i++) { scopes.push(opts.scopes.require[i]) }\n\t\t}\n\t\treturn utils.uniqueList(scopes)\n\t}\n\n\tgetToken(opts) {\n\t\treturn this.store.getToken(this.connector_name, this.config.config.scopes);\n\t}\n\n\t/*\n\t * 2nd portion of authorize method.  Was put into its own method to cope with an optional async path that happens when\n\t *  use_pkce is specified\n\t */\n\t_authorize2(request, code_verifier, scopes) {\n\n\t\tlet authorization = this.config.getValue('authorization', null, true)\n\n\t\tutils.log(\"Debug Authentication request object\", JSON.stringify(request, undefined, 2))\n\n\t\tvar authurl = utils.encodeURL(authorization, request)\n\n\t\t// After authurl has been established, some other state is stored within the request object which is persisted\n\t\t// Keep generated code_verifier around as we need to send it with the code challenge to retrieve token\n\t\tlet bUsePKCE = this.config.getValue('use_pkce', false);\n\t\tif (bUsePKCE) {\n\t\t\trequest.code_verifier = code_verifier;\n\t\t}\n\n\t\t// We'd like to cache the hash for not loosing Application state.\n\t\t// With the implciit grant flow, the hash will be replaced with the access\n\t\t// token when we return after authorization.\n\t\tif (window.location.hash) {\n\t\t\trequest.restoreHash = window.location.hash;\n\t\t}\n\t\trequest.connector_name = this.connector_name;\n\n\t\t// If there were specific scopes established, save within state\n\t\tif (scopes) {\n\t\t\trequest.scopes = scopes;\n\t\t}\n\n\t\tutils.log(\"Saving state [\" + request.state + \"]\");\n\t\tutils.log(JSON.parse(JSON.stringify(request)));\n\n\t\tvar loader = this.Loader;\n\n\t\tthis.store.saveState(request.state, request)\n\t\treturn this.gotoAuthorizeURL(authurl, loader)\n\t\t\t.then((response) => {\n\t\t\t\tdebugger; // when is that reached ??\n\t\t\t\tif (response !== true) {\n\t\t\t\t\treturn this.callback(response)\n\t\t\t\t}\n\t\t\t})\n\n\t}\n\n\t/**\n\t * Send authorization request.\n\t *\n\t * @param  {[type]} opts These options matches the ones sent in the \"oauth\" property of the ajax settings in the request.\n\t * @return {[type]}      [description]\n\t */\n\tauthorize() {\n\t\tvar request, scopes;\n\n\t\tlet authorization = this.config.getValue('authorization', null, true);\n\t\tlet client_id = this.config.getValue('client_id', null, true);\n\t\tlet use_pkce = this.config.getValue('use_pkce', false);\n\t\tlet openid = false;\n\n\t\tutils.log(\"About to send an authorization request to this endpoint\", authorization);\n\n\t\trequest = {};\n\t\trequest.state = utils.uuid();\n\t\trequest.response_type = this.config.getValue('response_type', 'id_token token');\n\t\tif (use_pkce) request.response_type = 'code';\n\n\t\tif (this.config.has('redirect_uri')) {\n\t\t\trequest.redirect_uri = this.config.getValue('redirect_uri', '');\n\t\t}\n\n\t\trequest.client_id = client_id;\n\n\t\t/*\n\t\t * Calculate which scopes to request, based upon provider config and request config.\n\t\t */\n\t\tscopes = this.config.config.scopes;\n\t\topenid = scopes.includes('openid');\n\t\tif (scopes.length > 0) {\n\t\t\trequest.scope = utils.scopeList(scopes);\n\t\t}\n\n\t\tutils.log(\"Running in mode: \" + (openid ? 'OpenID Connect mode' : 'OAuth mode'))\n\n\t\tif (openid && !request.hasOwnProperty('redirect_uri')) {\n\t\t\tthrow new Error('An OpenID Request requires a redirect_uri to be set. Please add to configuration. A redirect_uri is not required for plain OAuth')\n\t\t}\n\n\t\tif (openid) {\n\t\t\trequest.nonce = utils.uuid()\n\t\t}\n\n\t\t// If pkce is being utilized, create random code_verifier and create challenge\n\t\tlet cv = null;\n\t\tif (use_pkce) {\n\t\t\tif (!window.crypto) {\n\t\t\t\tthrow new Error('Browser crypto APIs are not available')\n\t\t\t}\n\n\t\t\t// RFC 7636 says the random string should be between 43 and 128 chars\n\t\t\t// Use 64 char buf for now\n\t\t\tvar buf = new Uint8Array(64)\n\t\t\twindow.crypto.getRandomValues(buf)\n\t\t\tcv = utils.base64UrlSafeEncode(buf)\n\n\t\t\tutils.getCodeChallenge(cv).then(cc => {\n\t\t\t\trequest.code_challenge = cc\n\t\t\t\t//Generate string sequence\n\t\t\t\trequest.code_challenge_method = \"S256\"\n\n\t\t\t\treturn this._authorize2(request, cv, scopes);\n\t\t\t});\n\n\t\t} else {\n\t\t\treturn this._authorize2(request, cv, scopes);\n\t\t}\n\t}\n\n\tgotoAuthorizeURL(url, Loader) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tif (Loader !== null && typeof Loader === 'function') {\n\t\t\t\tvar loader = new Loader(url)\n\t\t\t\tif (!(loader instanceof BasicLoader)) {\n\t\t\t\t\tthrow new Error(\"JSO selected Loader is not an instance of BasicLoader.\")\n\t\t\t\t}\n\t\t\t\tresolve(loader.execute())\n\t\t\t} else {\n\t\t\t\treject(new Error('Cannot redirect to authorization endpoint because of missing redirect handler'))\n\t\t\t}\n\t\t})\n\t}\n\n\twipeTokens() {\n\t\tthis.store.wipeTokens(this.connector_name)\n\t}\n\n}\n\n// Object.assign(JSO.prototype, new EventEmitter({}))\n\nexport { JSO, BasicLoader, HTTPRedirect, Popup, IFramePassive, IFrameActive, Fetcher, FetcherJQuery }\n// Work in progress\n// Authentication\n"],"sourceRoot":""}